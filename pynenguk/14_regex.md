# Python для мережевих інженерів

---

# Регулярні вирази

---
## Регулярні вирази

Регулярний вираз - це послідовність із звичайних та спеціальних символів. Ця послідовність визначає шаблон, який пізніше використовується для пошуку підрядків.

При роботі з мережевим обладнанням регулярні вирази можуть використовуватися, наприклад, для:

* отримання інформації з команд show
* відбору частини рядків з команд show, які збігаються із шаблоном
* перевірки, чи є певні налаштування у конфігурації

---
## Регулярні вирази

```
MacAddress          IpAddress        Lease(sec)  Type           VLAN  Interface
------------------  ---------------  ----------  -------------  ----  --------------------
00:09:BB:3D:D6:58   10.1.10.2        86250       dhcp-snooping   10    FastEthernet0/1
00:04:A3:3E:5B:69   10.1.5.2         63951       dhcp-snooping   5     FastEthernet0/10
00:05:B3:7E:9B:60   10.1.5.4         63253       dhcp-snooping   5     FastEthernet0/9
00:09:BC:3F:A6:50   10.1.10.6        76260       dhcp-snooping   10    FastEthernet0/3
Total number of bindings: 4
```

---
## Регулярні вирази

```
\d+ +[a-f0-9.]+ +\S+ +\S+
```


```
sw1#sh mac address-table
          Mac Address Table
-------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       --------    -----
 100    a1b2.ac10.7000    DYNAMIC     Gi0/1
 200    a0d4.cb20.7000    DYNAMIC     Gi0/2
 300    acb4.cd30.7000    DYNAMIC     Gi0/3
1100    a2bb.ec40.7000    DYNAMIC     Gi0/4
 500    aa4b.c550.7000    DYNAMIC     Gi0/5
1200    a1bb.1c60.7000    DYNAMIC     Gi0/6
1300    aa0b.cc70.7000    DYNAMIC     Gi0/7
```

---
## Синтаксис регулярних виразів

---
## Синтаксис регулярних виразів

---
### Синтаксис регулярних виразів

Набори символів:
* ```\d``` - будь-яка цифра
* ```\D``` - будь-який символ, крім цифр
* ```\s``` - whitespace (```\t\n\r\f\v```)
* ```\S``` - все, крім whitespace
* ```\w``` - будь-яка буква, цифра або нижнє підкреслення
* ```\W``` - все, крім літер, цифр і нижнього підкреслення


---
### Синтаксис регулярних виразів

Символи повторення:
* ```regex*``` - нуль або більше повторень попереднього елемента
* ```regex+``` - одне або більше повторень попереднього елемента
* ```regex?``` - нуль або одне повторення попереднього елемента
* ```regex{n}``` - рівно n повторень попереднього елемента
* ```regex{n,m}``` - від n до m повторень попереднього елемента
* ```regex{n,}``` - n або більше повторень попереднього елемента


---
### Синтаксис регулярних виразів

Спеціальні символи:
* ```.``` - будь-який символ, крім символу нового рядка
* ```^``` - початок рядка
* ```$``` - кінець рядка
* ```[abc]``` - будь-який символ у дужках
* ```[^abc]``` - будь-який символ, крім тих, що в дужках
* ```a|b``` - елемент a або b
* ```(regex)``` - вираз розглядається як один елемент. Крім того, підрядок, який збігся з виразом, запам'ятовується


---
## Набори символів

---
### Набори символів

У Python є спеціальні позначення для наборів символів:

* ```\d``` - будь-яка цифра
* ```\D``` - будь-яке нечислове значення
* ```\s``` - whitespace (\t\n\r\f\v)
* ```\S``` - все, крім whitespace
* ```\w``` - будь-яка буква, цифра або нижнє підкреслення
* ```\W``` - все, крім букв, цифр або нижнього підкреслення


---
### Набори символів

Набори символів дозволяють писати коротші вирази без необхідності перераховувати всі потрібні символи.

Наприклад, отримаємо час із рядка лог-файлу:
```python
In [1]: log = '*Jul  7 06:15:18.695: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/3, changed state to down'

In [2]: re.search('\d\d:\d\d:\d\d', log).group()
Out[2]: '06:15:18'

```

Вираз ``\d\d:\d\d:\d\d`` описує 3 пари чисел, розділених двокрапками.

---
### Набори символів

Отримання MAC-адреси з лог-повідомлення:
```python
In [3]: log2 = 'Jun  3 14:39:05.941: %SW_MATM-4-MACFLAP_NOTIF: Host f03a.b216.7ad7 in vlan 10 is flapping between port Gi0/5 and port Gi0/15'

In [4]: re.search('\w\w\w\w\.\w\w\w\w\.\w\w\w\w', log2).group()
Out[4]: 'f03a.b216.7ad7'

```

Вираз ``\w\w\w\w\.\w\w\w\w\.\w\w\w\w`` описує 12 букв або цифр, які розділені на три групи по чотири символи крапками .

---
## Символи повторення

---
### Символи повторення

* ```regex+``` - одне або більше повторень попереднього елемента
* ```regex*``` - нуль або більше повторень попереднього елемента
* ```regex?``` - нуль або одне повторення попереднього елемента
* ```regex{n}``` - рівно n повторень попереднього елемента
* ```regex{n,m}``` - від n до m повторень попереднього елемента
* ```regex{n, }``` - n або більше повторень попереднього елемента




---
### ```+```

Плюс вказує, що попередній вираз може повторюватися скільки завгодно разів, але, як мінімум, один раз.

Наприклад, тут повторення відноситься до літери a:
```py
In [1]: line = '100     aab1.a1a1.a5d3    FastEthernet0/1'

In [2]: re.search('a+', line).group()
Out[2]: 'aa'
```

---
### ```+```

В цьому виразі повторюється рядок 'a1':
```py
In [3]: line = '100     aab1.a1a1.a5d3    FastEthernet0/1'

In [4]: re.search('(a1)+', line).group()
Out[4]: 'a1a1'

```

---
### ```+```

IP-адресу можна описати виразом ``\d+\.\d+\.\d+\.\d+``.
Тут плюс використовується, щоб зазначити, що цифр може бути кілька.
А також зустрічається вираз ``\.``.

Воно необхідне тому, що крапка є спеціальним символом (вона позначає будь-який символ).
І щоб вказати, що нас цікавить саме символ крапка, її потрібно екранувати – помістити перед крапкою зворотний слеш.

---
### ```+```

Використовуючи цей вираз, можна отримати IP-адресу з рядка sh_ip_int_br:
```python
In [5]: sh_ip_int_br = 'Ethernet0/1    192.168.200.1   YES NVRAM  up          up'

In [6]: re.search('\d+\.\d+\.\d+\.\d+', sh_ip_int_br).group()
Out[6]: '192.168.200.1'
```

---
### ```+```

Ще один приклад виразу: ``\d+\s+\S+`` - описує рядок, в якому йдуть цифри, пробільні (whitespace) символи, не пробільні символи.
З його допомогою можна отримати VLAN та MAC-адресу з рядка:
```py
In [7]: line = '1500     aab1.a1a1.a5d3    FastEthernet0/1'

In [8]: re.search('\d+\s+\S+', line).group()
Out[8]: '1500     aab1.a1a1.a5d3'

```


---
### ```*```

Зірочка вказує, що попередній вираз може повторюватися 0 або більше разів.

Наприклад, якщо зірочка стоїть після символу, вона означає повторення цього символу.

Вираз ``ba*`` означає b, а потім нуль або більше повторень a:
```py
In [9]: line = '100     a011.baaa.a5d3    FastEthernet0/1'

In [10]: re.search('ba*', line).group()
Out[10]: 'baaa'
```

---
### ```*```

Якщо в рядку line до підрядка baaa зустрінеться b, то збігом буде b:
```py
In [11]: line = '100     ab11.baaa.a5d3    FastEthernet0/1'

In [12]: re.search('ba*', line).group()
Out[12]: 'b'

```

---
### ```*```

Допустимо, необхідно написати регулярний вираз, який описує email'и двох форматів: user@example.com та user.test@example.com.
Тобто, в лівій частині адреси може бути одне слово, або два слова, розділені крапкою.

Перший варіант на прикладі адреси без крапки:
```python
In [13]: email1 = 'user1@gmail.com'
```

Цю адресу можна описати таким виразом ```\w+@\w+\.\w+```:
```python
In [14]: re.search('\w+@\w+\.\w+', email1).group()
Out[14]: 'user1@gmail.com'
```

---
### ```*```

Але такий вираз не підходить для email з крапкою:
```python
In [15]: email2 = 'user2.test@gmail.com'

In [16]: re.search('\w+@\w+\.\w+', email2).group()
Out[16]: 'test@gmail.com'
```

---
### ```*```

Регулярний вираз адреси з крапкою:
```python
In [17]: re.search('\w+\.\w+@\w+\.\w+', email2).group()
Out[17]: 'user2.test@gmail.com'
```

Щоб описати обидва варіанти адрес, треба вказати, що крапка в адресі опціональна:
```
'\w+\.*\w+@\w+\.\w+'
```

---
### ```*```

Такий регулярний вираз описує обидва варіанти:
```python
In [18]: email1 = 'user1@gmail.com'

In [19]: email2 = 'user2.test@gmail.com'

In [20]: re.search('\w+\.*\w+@\w+\.\w+', email1).group()
Out[20]: 'user1@gmail.com'

In [21]: re.search('\w+\.*\w+@\w+\.\w+', email2).group()
Out[21]: 'user2.test@gmail.com'
```

---
### ```?```

В останньому прикладі регулярний вираз показує, що крапка опціональна,
Проте, водночас, вказує і те, що крапка може зустрічатися багато разів.

У цій ситуації логічніше використати знак питання.
Він вказує, що попередній вираз буде повторюватися нуль чи один раз.
Тепер регулярний вираз виглядає так ```\w+\.?\w+@\w+\.\w+```:
```python
In [22]: mail_log = ['Jun 18 14:10:35 client-ip=154.10.180.10 from=user1@gmail.com, size=551',
     ...:             'Jun 18 14:11:05 client-ip=150.10.180.10 from=user2.test@gmail.com, size=768']

In [23]: for message in mail_log:
     ...:     match = re.search('\w+\.?\w+@\w+\.\w+', message)
     ...:     if match:
     ...:         print("Found email: ", match.group())
     ...:
Found email:  user1@gmail.com
Found email:  user2.test@gmail.com
```

---
### ```{n}```

За допомогою фігурних дужок можна вказати, скільки разів має повторюватися попередній вираз.

Наприклад, вираз ``\w{4}\.\w{4}\.\w{4}`` описує 12 букв або цифр, які розділені на три групи по чотири символи крапками. Таким чином можна отримати MAC-адресу:
```py
In [24]: line = '100     aab1.a1a1.a5d3    FastEthernet0/1'

In [25]: re.search('\w{4}\.\w{4}\.\w{4}', line).group()
Out[25]: 'aab1.a1a1.a5d3'

```

---
### ```{n}```

У фігурних дужках можна вказувати діапазон повторень.

```python
mac_table = '''
sw1#sh mac address-table
          Mac Address Table
-------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       --------    -----
 100    a1b2.ac10.7000    DYNAMIC     Gi0/1
 200    a0d4.cb20.7000    DYNAMIC     Gi0/2
 300    acb4.cd30.7000    DYNAMIC     Gi0/3
1100    a2bb.ec40.7000    DYNAMIC     Gi0/4
'''
```

search шукає тільки перший збіг, тому у вираз "\d{1,4}" потрапить номер VLAN:
```python
In [27]: for line in mac_table.split('\n'):
    ...:     match = re.search('\d{1,4}', line)
    ...:     if match:
    ...:         print('VLAN: ', match.group())
    ...:
VLAN:  1
VLAN:  100
VLAN:  200
VLAN:  300
VLAN:  1100
```

---
### ```{n}```

Вираз ```\d{1,4}``` описує від однієї до чотирьох цифр.

Зауважте, що у виведенні команди немає першого VLAN.
Такий результат вийшов через те, що в імені комутатора є цифра, і вона збіглася з виразом.

Щоб виправити це, достатньо доповнити вираз і вказати, що після цифр має йти хоча б один пробіл:

```python
In [28]: for line in mac_table.split('\n'):
    ...:     match = re.search('\d{1,4} +', line)
    ...:     if match:
    ...:         print('VLAN: ', match.group())
    ...:
VLAN:  100
VLAN:  200
VLAN:  300
VLAN:  1100

```

---
## Спеціальні символи

---
## Спеціальні символи

* ```.``` - будь-який символ, крім символу нового рядка
* ```^``` - початок рядка
* ```$``` - кінець рядка
* ```[abc]``` - будь-який символ у дужках
* ```[^abc]``` - будь-який символ, крім тих, що в дужках
* ```a|b``` - елемент a або b
* ```(regex)``` - вираз розглядається як один елемент. Крім того, підрядок, який збігся з виразом, запам'ятовується


---
### ```.```

Крапка позначає будь-який символ.

Найчастіше, крапка використовується з символами повторення ``+`` і ``*``, щоб вказати, що між певними виразами можуть бути будь-які символи.


---
### ```.```

Наприклад, за допомогою виразу ```Interface.+Port ID.+``` можна описати рядок з інтерфейсами у виводі sh cdp neighbors detail:

```python
In [1]: cdp = '''
   ...: SW1#show cdp neighbors detail
   ...: -------------------------
   ...: Device ID: SW2
   ...: Entry address(es):
   ...:   IP address: 10.1.1.2
   ...: Platform: cisco WS-C2960-8TC-L,  Capabilities: Switch IGMP
   ...: Interface: GigabitEthernet1/0/16,  Port ID (outgoing port): GigabitEthernet0/1
   ...: Holdtime : 164 sec
   ...: '''

In [2]: re.search('Interface.+Port ID.+', cdp).group()
Out[2]: 'Interface: GigabitEthernet1/0/16,  Port ID (outgoing port): GigabitEthernet0/1'
```

---
### ```^```

Символ ```^``` означає початок рядка. Виразу ``^\d+`` відповідає підрядок:
```python
In [3]: line = "100 aa12.35fe.a5d3 FastEthernet0/1"

In [4]: ​​re.search('^\d+', line).group()
Out[4]: '100'
```

---
### ```^```

Символи з початку рядка і до ґрат (включаючи ґрати):
```py
In [5]: prompt = 'SW1#show cdp neighbors detail'

In [6]: re.search('^.+#', prompt).group()
Out[6]: 'SW1#'
```

---
### ```$```

Символ ```$``` означає кінець рядка.

Вираз ```\S+$``` описує будь-які символи, крім whitespace в кінці рядка:
```python
In [7]: line = "100 aa12.35fe.a5d3 FastEthernet0/1"

In [8]: re.search('\S+$', line).group()
Out[8]: 'FastEthernet0/1'
```

---
### ```[]```

Символи, які перераховані у квадратних дужках, означають, що будь-який із цих символів буде збігом.
Таким чином можна описувати різні регістри:
```python
In [9]: line = "100     aa12.35fe.a5d3    FastEthernet0/1"

In [10]: re.search('[Ff]ast', line).group()
Out[10]: 'Fast'

In [11]: re.search('[Ff]ast[Ee]thernet', line).group()
Out[11]: 'FastEthernet'
```

---
### ```[]```

За допомогою квадратних дужок можна вказати які символи можуть зустрічатися на конкретній позиції.
Наприклад, вираз ``^.+[>#]`` описує символи з початку рядка до символу ґрат або знака більше (включаючи їх).
За допомогою такого виразу можна отримати ім'я пристрою:
```python
In [12]: commands = ['SW1#show cdp neighbors detail',
    ...:             'SW1>sh ip int br',
    ...:             'r1-london-core# sh ip route']
    ...:

In [13]: for line in commands:
    ...:     match = re.search('^.+[>#]', line)
    ...:     if match:
    ...:         print(match.group())
    ...:
SW1#
SW1>
r1-london-core#
```

---
### ```[]```

У квадратних дужках можна вказувати діапазон символів.
Наприклад, таким чином можна вказати, що нас цікавить будь-яка цифра від 0 до 9:
```py
In [14]: line = "100 aa12.35fe.a5d3 FastEthernet0/1"

In [15]: re.search('[0-9]+', line).group()
Out[15]: '100'

```

---
### ```[]```

Аналогічно можна вказати літери:
```py
In [16]: line = "100 aa12.35fe.a5d3 FastEthernet0/1"

In [17]: re.search('[a-z]+', line).group()
Out[17]: 'aa'

In [18]: re.search('[A-Z]+', line).group()
Out[18]: 'F'

```

---
### ```[]```

У квадратних дужках можна вказувати кілька діапазонів:
```py
In [19]: line = "100 aa12.35fe.a5d3 FastEthernet0/1"

In [20]: re.search('[a-f0-9]+\.[a-f0-9]+\.[a-f0-9]+', line).group()
Out[20]: 'aa12.35fe.a5d3'

```

---
### ```[]```

Вираз ``[a-f0-9]+\.[a-f0-9]+\.[a-f0-9]+`` описує три групи символів, розділених крапкою.
Символами кожної групи можуть бути літери a-f або цифри 0-9.
Цей вираз описує MAC-адресу.

Ще одна особливість квадратних дужок – спеціальні символи всередині квадратних дужок втрачають своє спеціальне значення та позначають просто символ.
Наприклад, крапка всередині квадратних дужок позначатиме крапку, а не будь-який символ.

---
### ```[]```

Вираз ``[a-f0-9]+[./][a-f0-9]+`` описує три групи символів:
1. літери a-f чи цифри від 0 до 9
2. крапка або прямий слеш
3. літери a-f або цифри від 0 до 9

---
### ```[]```

Для рядка line збігом буде такий підрядок:
```py
In [21]: line = "100 aa12.35fe.a5d3 FastEthernet0/1"

In [22]: re.search('[a-f0-9]+[./][a-f0-9]+', line).group()
Out[22]: 'aa12.35fe'

```

---
### ```[]```

Якщо після квадратної дужки, що відкривається, вказаний символ ``^``, збігом буде будь-який символ, крім зазначених у дужках:
```python
In [23]: line = 'FastEthernet0/0 15.0.15.1 YES manual up up'

In [24]: re.search('[^a-zA-Z]+', line).group()
Out[24]: '0/0 15.0.15.1 '

```

У цьому випадку вираз описує все, крім букв.

---
### ```|```

Вертикальна риска працює як 'або':
```python
In [25]: line = "100     aa12.35fe.a5d3    FastEthernet0/1"

In [26]: re.search('Fast|0/1', line).group()
Out[26]: 'Fast'
```

Зверніть увагу на те, як спрацьовує ``|`` - `Fast` і `0/1` сприймаються як цілий вираз.
Тобто вираз означає, що ми шукаємо `Fast` або `0/1`, а не те, що ми шукаємо `Fas`, потім `t` або `0` і `0/1`.


---
### ```()```

Дужки використовуються для групування виразів.
За допомогою дужок можна зазначити, яких елементів застосовується операція.

Наприклад, такий вираз описує три символи: цифра, потім буква або цифра і цифра:
```python
[0-9]([a-f]|[0-9])[0-9]
```

Приклад використання
```python
In [27]: line = "100 aa12.35fe.a5d3 FastEthernet0/1"

In [28]: re.search('[0-9]([a-f]|[0-9])[0-9]', line).group()
Out[28]: '100'

```

---
### ```()```

Дужки дозволяють вказувати, який вираз є одним цілим.
Це особливо корисно при використанні символів повторення:
```py
In [29]: line = 'FastEthernet0/0 15.0.15.1 YES manual up up'

In [30]: re.search('([0-9]+\.)+[0-9]+', line).group()
Out[30]: '15.0.15.1'
```

---
## Жадібність символів повторення

---
### Жадібність символів повторення

За замовчуванням символи повторення у регулярних виразах жадібні (greedy).
Це означає, що результуючий підрядок, який відповідає шаблону, буде найдовшим.

Приклад жадібної поведінки:
```python
In [1]: import re
In [2]: line = '<text line> some text>'
In [3]: match = re.search('<.*>', line)

In [4]: match.group()
Out[4]: '<text line> some text>'
```

В даному випадку вираз захопив максимально довгу послідовність символів, всередині `<>`.

---
### Жадібність символів повторення

Якщо потрібно відключити жадібність, достатньо додати знак питання після символів повторення:
```python
In [5]: line = '<text line> some text>'

In [6]: match = re.search('<.*?>', line)

In [7]: match.group()
Out[7]: '<text line>'
```

---
### Жадібність символів повторення

Найчастіше жадібність корисна.
Наприклад, без відключення жадібності останнього плюсу, вираз ``\d+\s+\S+`` описує такий рядок:
```python
In [8]: line = '1500 aab1.a1a1.a5d3 FastEthernet0/1'

In [9]: re.search('\d+\s+\S+', line).group()
Out[9]: '1500 aab1.a1a1.a5d3'
```

---
### Жадібність символів повторення

Символ ``\S`` позначає все, окрім whitespace.
Тому вираз ```\S+``` з жадібним символом повторення описує максимально довгий рядок до першого whitespace символу.
В даному випадку – до першого пробілу.

Але якщо відключити жадібність, результат буде таким:
```python
In [10]: re.search('\d+\s+\S+?', line).group()
Out[10]: '1500 a'
```

---
## Використання груп

---
### Використання груп

Зазначення символів/виразів в дужках вказує, що послідовність символів треба сприймати як одне ціле.

Крім цього, за допомогою груп можна отримувати лише певну частину рядка, що була описана виразом.
Це дуже корисно в ситуаціях, коли треба описати рядок досить докладно, щоб відібрати потрібні рядки, але в той же час із самого рядка треба отримати лише певне значення.

---
### Використання груп

Наприклад, з log-файлу треба відібрати рядки, в яких зустрічається "%SW_MATM-4-MACFLAP_NOTIF", а потім з кожного такого рядка отримати MAC-адресу, VLAN та інтерфейси.
У цьому випадку регулярний вираз повинен описувати рядок, а всі частини рядка, які треба запам'ятати, мають бути записані у дужках.

У Python є два варіанти використання груп:
* Нумеровані групи
* Іменовані групи

---
### Нумеровані групи

Група визначається шляхом розміщення виразу в круглих дужках `()`.

Всередині виразу групи нумеруються зліва направо, починаючи з 1.  
До груп можна звертатися за номерами та отримувати текст, який відповідає виразу у групі.

Приклад використання груп:

```python
In [8]: line = "FastEthernet0/1 10.0.12.1 YES manual up up"
In [9]: match = re.search('(\S+)\s+([\w.]+)\s+.*', line)
```


Звернення до груп за номером (група 0 - це рядок, який відповідає всьому збігу):

```python
In [10]: match.group(0)
Out[10]: 'FastEthernet0/1 10.0.12.1 YES manual up up'

In [11]: match.group(1)
Out[11]: 'FastEthernet0/1'

In [12]: match.group(2)
Out[12]: '10.0.12.1'
```

---
### Нумеровані групи

За потреби можна перерахувати кілька номерів груп:

```python
In [13]: match.group(1, 2)
Out[13]: ('FastEthernet0/1', '10.0.12.1')

In [14]: match.group(2, 1, 2)
Out[14]: ('10.0.12.1', 'FastEthernet0/1', '10.0.12.1')
```

---
### Нумеровані групи

Починаючи з версії Python 3.6, до груп можна звертатися таким чином:

```python
In [15]: match[0]
Out[15]: 'FastEthernet0/1 10.0.12.1 YES manual up up'

In [16]: match[1]
Out[16]: 'FastEthernet0/1'

In [17]: match[2]
Out[17]: '10.0.12.1'
```

---
### Нумеровані групи

Для виведення всіх підрядків, які відповідають зазначеним групам, використовується метод groups:

```python
In [18]: match.groups()
Out[18]: ('FastEthernet0/1', '10.0.12.1')
```

---
### Іменовані групи

Якщо регулярний вираз великий і в ньому багато груп, може бути не дуже зручно використовувати нумеровані групи.
Особливо, враховуючи те, що при доповненні виразу, може вийти так, що порядок груп змінився, і доведеться змінити код, який посилається на групи.

Іменовані групи дозволяють задавати групі ім'я.

Синтаксис іменованої групи `(?P<name>regex)`:

```python
In [19]: line = "FastEthernet0/1 10.0.12.1 YES manual up up"

In [20]: match = re.search('(?P<intf>\S+)\s+(?P<address>[\d.]+)\s+', line)
```

---
### Іменовані групи

Тепер до цих груп можна звертатися за ім'ям:

```python
In [21]: match.group('intf')
Out[21]: 'FastEthernet0/1'

In [22]: match.group('address')
Out[22]: '10.0.12.1'
```

---
### Іменовані групи

Також дуже корисно те, що за допомогою методу groupdict можна отримати словник, де ключі - імена груп, а значення - підрядки, які їм відповідають:

```python
In [23]: match.groupdict()
Out[23]: {'address': '10.0.12.1', 'intf': 'FastEthernet0/1'}
```

---
### Іменовані групи

І, в такому разі, можна додати групи в регулярний вираз і покладатися на їхнє ім'я, а не на порядок:

```python
In [24]: match = re.search('(?P<intf>\S+)\s+(?P<address>[\d\.]+)\s+\w+\s+\w+\s+(?P<status>up|down|administratively down)\s+(?P<protocol>up|down)', line)

In [25]: match.groupdict()
Out[25]:
{'address': '10.0.12.1',
 'intf': 'FastEthernet0/1',
 'protocol': 'up',
 'status': 'up'}
```


---
## Група без захоплення

---
### Група без захоплення

За замовчуванням все, що потрапило до групи, запам'ятовується.
Це називається група із захопленням.

Іноді дужки потрібні для того щоб вказати частину повторюваного виразу і при цьому не потрібно запам'ятовувати вираз.

---
### Група без захоплення

Наприклад, треба отримати MAC-адресу, VLAN та порти з такого лог-повідомлення:
```python
In [1]: log = 'Jun  3 14:39:05.941: %SW_MATM-4-MACFLAP_NOTIF: Host f03a.b216.7ad7 in vlan 10 is flapping between port Gi0/5 and port Gi0/15'
```

Регулярний вираз, який описує потрібні підрядки:
```python
In [2]: match = re.search('(([0-9a-fA-F]{4}\.){2}[0-9a-fA-F]{4}).+vlan (\d+).+port (\S+).+port (\S+)', log)
```

---
### Група без захоплення

Вираз складається з таких частин:
* ```(([0-9a-fA-F]{4}\.){2}[0-9a-fA-F]{4})``` - сюди потрапить MAC-адреса
  * ```[0-9a-fA-F]{4}\.``` - ця частина описує 4 літери або цифри та крапку
  * ```([0-9a-fA-F]{4}\.){2}``` - тут дужки потрібні, щоб вказати, що 4 літери або цифри і крапка повторюються два рази
  * ``[0-9a-fA-F]{4}`` - потім 4 літери або цифри
* ```.+vlan (\d+)``` - до групи потрапить номер VLAN 
* ```.+port (\S+)``` - перший інтерфейс
* ```.+port (\S+)``` - другий інтерфейс

---
### Група без захоплення

Метод groups поверне такий результат:
```python
In [3]: match.groups()
Out[3]: ('f03a.b216.7ad7', 'b216.', '10', 'Gi0/5', 'Gi0/15')
```

---
### Група без захоплення

Другий елемент, насправді, зайвий. Він потрапив у висновок через дужки у виразі ``([0-9a-fA-F]{4}\.){2}``.

В цьому випадку потрібно вимкнути захоплення у групі.
Це робиться додаванням ``?:`` після дужки групи, що відкривається.

---
### Група без захоплення

Тепер вираз виглядає так:
```python
In [4]: match = re.search('((?:[0-9a-fA-F]{4}\.){2}[0-9a-fA-F]{4}).+vlan (\d+).+port (\S+).+port (\S+)', log)
```

І, відповідно, групи:
```python
In [5]: match.groups()
Out[5]: ('f03a.b216.7ad7', '10', 'Gi0/5', 'Gi0/15')
```


---
## Повторення захопленого результату

---
### Повторення захопленого результату

При роботі з групами можна використати результат, який потрапив до групи, далі у тому ж виразі.

Наприклад, у виводі sh ip bgp останній стовпець описує атрибут AS Path (через які автономні системи пройшов маршрут):
```
bgp = '''
R9# sh ip bgp | be Network
   Network          Next Hop       Metric LocPrf Weight Path
*  192.168.66.0/24  192.168.79.7                       0 500 500 500 i
*>                  192.168.89.8                       0 800 700 i
*  192.168.67.0/24  192.168.79.7         0             0 700 700 700 i
*>                  192.168.89.8                       0 800 700 i
*  192.168.88.0/24  192.168.79.7                       0 700 700 700 i
*>                  192.168.89.8         0             0 800 800 i
'''
```

---
### Повторення захопленого результату

Припустимо, треба отримати ті префікси, у яких у Path кілька разів повторюється один і той самий номер AS.

Це можна зробити за допомогою посилання на результат, захоплений групою.
Наприклад, такий вираз відображає всі рядки, в яких один і той же номер повторюється хоча б двічі:
```python
In [2]: for line in bgp.split('\n'):
   ...:     match = re.search(r'(\d+) \1', line)
   ...:     if match:
   ...:         print(line)
   ...:
*  192.168.66.0/24  192.168.79.7                       0 500 500 500 i
*  192.168.67.0/24  192.168.79.7         0             0 700 700 700 i
*  192.168.88.0/24  192.168.79.7                       0 700 700 700 i
*>                  192.168.89.8         0             0 800 800 i
```

---
### Повторення захопленого результату

У цьому виразі позначення ``\1`` підставляє результат, який потрапив до групи. Номер один вказує на конкретну групу.
В даному випадку, це група 1.


---
### Повторення захопленого результату

Аналогічним чином можна описати рядки, в яких один і той же номер зустрічається тричі:
```python
In [3]: for line in bgp.split('\n'):
   ...:     match = re.search(r'(\d+) \1 \1', line)
   ...:     if match:
   ...:         print(line)
   ...:
*  192.168.66.0/24  192.168.79.7                       0 500 500 500 i
*  192.168.67.0/24  192.168.79.7         0             0 700 700 700 i
*  192.168.88.0/24  192.168.79.7                       0 700 700 700 i

```

---
### Повторення захопленого результату

Також можна посилатися на результат, який потрапив до іменованої групи:
```python
In [129]: for line in bgp.split('\n'):
     ...:     match = re.search('(?P<as>\d+) (?P=as)', line)
     ...:     if match:
     ...:         print(line)
     ...:
*  192.168.66.0/24   192.168.79.7                       0 500 500 500 i
*  192.168.67.0/24   192.168.79.7         0             0 700 700 700 i
*  192.168.88.0/24   192.168.79.7                       0 700 700 700 i
*>                   192.168.89.8         0             0 800 800 i

```

